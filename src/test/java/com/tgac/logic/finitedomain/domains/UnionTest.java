package com.tgac.logic.finitedomain.domains;
// Generated by CodiumAI

import com.tgac.logic.finitedomain.Domain;
import io.vavr.collection.Array;
import org.assertj.core.api.Assertions;
import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

public class UnionTest {

	@Test
	public void shouldMergeNonOverlappingDomains() {
		// Create two non-overlapping domains
		Interval<Integer> domain1 = Interval.of(1, 3);
		Interval<Integer> domain2 = Interval.of(4, 6);

		// Create an array of the two domains
		Array<Domain<Integer>> intervals = Array.of(domain1, domain2);

		// Call the mergeOverlappingDomains method
		Array<Domain<Integer>> mergedDomains = Union.mergeOverlappingIntervals(intervals);

		// Assert that the mergedDomains array contains a single domain with the expected values
		assertEquals(1, mergedDomains.size());
		assertEquals(
				Interval.of(1, 6),
				mergedDomains.get(0));
	}

	@Test
	public void test_mergeOverlappingDomains() {
		// Create two overlapping domains
		Interval<Integer> domain1 = Interval.of(1, 3);
		Interval<Integer> domain2 = Interval.of(3, 5);

		// Create an array of the two domains
		Array<Domain<Integer>> intervals = Array.of(domain1, domain2);

		// Call the mergeOverlappingDomains method
		Array<Domain<Integer>> mergedDomains = Union.mergeOverlappingIntervals(intervals);

		// Assert that the mergedDomains array contains a single domain with the expected values
		assertEquals(1, mergedDomains.size());
		assertEquals(Interval.of(1, 5), mergedDomains.get(0));
	}

	@Test
	public void shouldMergeMultipleOverlappingDomains() {
		// Create three overlapping domains
		Interval<Integer> domain1 = Interval.of(1, 3);
		Interval<Integer> domain2 = Interval.of(3, 5);
		Interval<Integer> domain3 = Interval.of(5, 7);

		// Create an array of the three domains
		Array<Domain<Integer>> intervals = Array.of(domain1, domain2, domain3);

		// Call the mergeOverlappingDomains method
		Array<Domain<Integer>> mergedDomains = Union.mergeOverlappingIntervals(intervals);

		// Assert that the mergedDomains array contains a single domain with the expected values
		assertEquals(1, mergedDomains.size());
		assertEquals(Interval.of(1, 7), mergedDomains.get(0));
	}

	@Test
	public void shouldMergeSingletons() {
		// Create two overlapping domains
		Singleton<Integer> domain1 = Singleton.of(1);
		Singleton<Integer> domain2 = Singleton.of(1);

		// Create an array of the two domains
		Array<Domain<Integer>> intervals = Array.of(domain1, domain2);

		// Call the mergeOverlappingDomains method
		Array<Domain<Integer>> mergedDomains = Union.mergeOverlappingIntervals(intervals);

		// Assert that the mergedDomains array contains a single domain with the expected values
		assertEquals(1, mergedDomains.size());
		assertEquals(Singleton.of(1), mergedDomains.get(0));
	}

	@Test
	public void shouldMergeConsecutiveSingletons() {
		// Create two overlapping domains
		Singleton<Integer> domain1 = Singleton.of(1);
		Singleton<Integer> domain2 = Singleton.of(2);

		// Create an array of the two domains
		Array<Domain<Integer>> intervals = Array.of(domain1, domain2);

		// Call the mergeOverlappingDomains method
		Array<Domain<Integer>> mergedDomains = Union.mergeOverlappingIntervals(intervals);

		// Assert that the mergedDomains array contains a single domain with the expected values
		assertEquals(1, mergedDomains.size());
		assertEquals(Interval.of(1, 2), mergedDomains.get(0));
	}

	@Test
	public void shouldMergeEmptyArray() {
		// Create an empty array of domains
		Array<Domain<Integer>> intervals = Array.empty();

		// Call the mergeOverlappingDomains method
		Array<Domain<Integer>> mergedDomains = Union.mergeOverlappingIntervals(intervals);

		// Assert that the mergedDomains array is empty
		assertTrue(mergedDomains.isEmpty());
	}

	@Test
	public void shouldRemoveEmptyDomains() {
		// Create a single empty domain
		Domain<Integer> domain = Empty.instance();

		// Create an array with the empty domain
		Array<Domain<Integer>> intervals = Array.of(domain);

		// Call the mergeOverlappingDomains method
		Array<Domain<Integer>> mergedDomains = Union.mergeOverlappingIntervals(intervals);

		// Assert that the mergedDomains array contains a single empty domain
		assertEquals(0, mergedDomains.size());
	}

	@Test
	public void shouldMergeSingleDomain() {
		// Create a single domain
		Interval<Integer> domain = Interval.of(1, 3);

		// Create an array with the domain
		Array<Domain<Integer>> intervals = Array.of(domain);

		// Call the mergeOverlappingDomains method
		Array<Domain<Integer>> mergedDomains = Union.mergeOverlappingIntervals(intervals);

		// Assert that the mergedDomains array contains a single domain with the expected values
		assertEquals(1, mergedDomains.size());
		assertEquals(domain, mergedDomains.get(0));
	}

	@Test
	public void shouldContainValue() {
		Domain<Integer> domain1 = Interval.of(1, 5);
		Domain<Integer> domain2 = Interval.of(10, 15);

		Union<Integer> union = Union.of(domain1, domain2);

		assertTrue(union.contains(3));
		assertFalse(union.contains(7));
	}

	@Test
	public void shouldStreamValues() {
		Domain<Integer> domain1 = Interval.of(1, 5);
		Domain<Integer> domain2 = Interval.of(10, 15);

		Union<Integer> union = Union.of(domain1, domain2);

		assertEquals(Array.of(1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15),
				union.stream().collect(Array.collector()));
	}

	@Test
	public void shouldCreateMultiIntervalFromEmptyArray() {
		Union<Integer> union = Union.of();

		assertTrue(union.getIntervals().isEmpty());
	}

	@Test
	public void shouldCreateMultiIntervalFromArrayOfEmptyDomains() {
		Empty<Integer> empty1 = Empty.instance();
		Empty<Integer> emptyDomain2 = Empty.instance();

		Union<Integer> union = Union.of(empty1, emptyDomain2);

		assertTrue(union.getIntervals().isEmpty());
	}

	@Test
	public void shouldDiffSimple() {
		Assertions.assertThat(
						Union.of(
										Interval.of(0, 10),
										Interval.of(20, 30))
								.difference(Interval.of(5, 25)))
				.isEqualTo(
						Union.of(
								Interval.of(0, 4),
								Interval.of(26, 30)));
	}

	@Test
	public void shouldDiffEnumerated() {
		Assertions.assertThat(
						Union.of(
										Interval.of(0, 10),
										Interval.of(20, 30))
								.difference(EnumeratedDomain.of(Array.of(5, 15, 25).map(Arithmetic::of))))
				.isEqualTo(
						Union.of(
								Interval.of(0, 4),
								Interval.of(6, 10),
								Interval.of(20, 24),
								Interval.of(26, 30)));
	}

}